# java学习笔记

## java基础

### 基本数据结构

#### 1.数组 

1.数组是相同数据类型的数据元素的有序集合

2.数组中的元素可以是任何类型的的数据类型，包括基本类型和引用类型，但是不能混用。

3.数组创建后，如果没有赋值，有默认值（int 0，short 0，byte 0，long 0, float 0.0, double 0.0, char \u0000, boolean false, string null) （？在main方法中有默认初始值，但是在成员方法中需要初始化）

4.使用数组的步骤：1.声明数组开辟空间 2.给数组各个元素赋值 3.使用数组

5.数组的下标是从0开始的

6.数组下标必须在指定范围内使用，否则会抱数组越界异常

7.数组属于引用类型，数组型数据是对象（object)

特点：在内存中连续存储，能实现元素的随机存取



##### 数组的初始化

java中数组必须先初始化![image-20210609233124524](study-notes\picture\image-20210609233124524.png)，所谓初始化就是为数组中的数组元素分配内存空间。并且为每个元素赋初值



###### 动态初始化：初始化时只指定数组长度，由jvm为数组分配初始值

###### 静态初始化：初始化时指定每个数组元素的初始值，由系统数组长度





##### 二维数组（多维数组）

1.一维数组的声明方式有：int[] x或int x[]

2.二维数组的声明方式有：int[][] y或int[] y[]或 int y[][]

3.二维数组实际上是由多个一位数组组成的，它的各个一维数组的长度可以相同，也可以不同。

例如：map[][]是一个二维数组，map[][] = {{1,2},{3,4,5}}是map[0]是一个含有两个元素的一维数组，map[1]是一个含有3个元素的一维数组构成，我们也称为列数不相等的二维数组。

![image-20210628141823045](study-notes/picture/image-20210628141823045.png)





值传递和 引用传递的区别

基本数据类型的赋值是复制给新声明的变量

数组的赋值是赋值的地址，两个变量指向堆上同一块内存空间



char的默认值\u0000



### 面向对象

#### 类和对象的内存分配机制

java内存的结构

1.栈：一般存放基本数据类型（局部变量）

2.堆：存放对象（Cat cat,数组等）

3.方法区：常量池（常量，比如字符串），类加载信息	



#### 方法重载(overload)

1.方法名：必须相同

2.参数列表：必须不同（参数类型或者个数和顺序，至少有一样不同，参数名无要求）

3.返回值类型：无要求





#### 可变参数

例如：

`Public int sum(int... sums){`

`}`

1.表示接收的是可变参数，类型是int，即可以接受多个int（0-多）

2.使用可变参数时，可以当作数组来使用，即nums可以当作数组

3.遍历nums求和即可





注意事项和使用细节

1.可变参数的实参可以为0个或任意多个

2.可变参数的实参可以为数组

3.可变参数的本质就是数组

4.可变参数可以和普通类型的 参数一起放在形参列表，但必须保证可变参数在最后

5.一个形参列表中只能出现一个可变参数



#### 成员方法传参机制

引用数据类型的传参机制

1.案例：B类中编写一个方法test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？

B类中编写一个方法test200，可以接收一个Person(age,sal)对象，在方法中修改该对象属性，看看原对象是否变化？

2.结论和示意图

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参

3.如果p=null和p =new Person();

![image-20210628144050007](/Users/wubianhu/Library/Application Support/typora-user-images/image-20210628144050007.png)

![image-20210628144103712](/Users/wubianhu/Library/Application Support/typora-user-images/image-20210628144103712.png)





#### 作用域

全局变量：也就是属性，作用域为整个类体。全局变量可以不赋值，直接使用，因为有默认值。

局部变量：局部变量必须赋值后，才能使用，因为没有默认值

注意事项和使用细节

1.属性和局部变量可以重名，访问时遵循就近原则

2.在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名

3.属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量生命周期较短，伴随着它的代码快的执行而创建，伴随着代码块的结束而销毁，即在一次方法调用过程中。

4.作用域范围不同

全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）

局部变量：只能在本类的对应方法中使用

5.修饰符不同

全局变量/属性可以加修饰符

局部变量不可以加修饰符



#### 构造方法/构造器

注意事项和使用细节

1.一个类可以定义多个不同的构造器，即构造器的重载

2.构造器名和类名要相同

3.构造器没有返回值

4.构造器是完成对象的初始化，并不是创建对象

5.在创建对象时，系统自动的调用该类的构造方法

6.如果没有定义构造方法，系统会自动给类生成一个默认无参的构造方法（也叫默认构造方法）

###### 可以用javap指令反编译查看

7.一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造，除非显示的定义一下









#### 对象创建的流程分析

例如：Person p = new Person("小倩"，20);

1.加载类信息（Person.class)，只会加载一次

2.在堆中分配空间（地址）

3.完成对象初始化

（1.默认初始化age=0，name=null

​	2.显示初始化age=90,name=null

​	3.构造器的初始化age=20,name="小倩"）

4.把对象在堆中的地址返回给p





#### this

this简单来说就是哪个对象调用，就代表哪个对象

注意事项和使用细节

1.this关键字可以用来访问本类的属性、方法、构造器

2.this用于区分当前类的属性和局部变量

3.访问成员方法的语法：this.方法名（参数列表）

4.访问构造器语法：this（参数列表）;注意只能在构造器中使用

注意：在一个构造器中访问另一个构造器，那么访问的语句必须放在第一条

![image-20210628150547364](/Users/wubianhu/Library/Application Support/typora-user-images/image-20210628150547364.png)

5.this不能在类的定义的外部使用，只能在类定义的方法中使用



###### this的使用好处不仅仅是代表类本身，因为变量的引用具有就近原则，如果在变量前面对变量进行了初始化，就会导致变量引用错误



#### 继承的深入讨论/细节问题

1.子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问

2.子类必须调用父类的构造器，完成父类的初始化

3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下都会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。

4.如果希望指定去调用父类的某个构造器，则显示的调用一下：super（参数列表）	

5.super在使用时，必须放在构造器的第一行(super只能在构造器中使用)

6.super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

7.java中所有类都是Object类的子类，Object是所有类的基类

8.父类构造器的调用不限于直接父类，将一直往上追溯直到Object类（顶级父类）





#### 方法重写/覆盖（override）

简单的来说，方法重写（覆盖）就是子类有一个方法和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法

![image-20210913155841102](/Users/wubianhu/Library/Application Support/typora-user-images/image-20210913155841102.png)

注意事项和使用细节

1.子类的方法的**参数，方法名称**，要和父类方法的参数，方法名称完全一样

2.子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。比如父类返回类型是Obejct，子类返回类型是String

3.子类方法不能缩小父类方法的访问权限。



关于方法重写和方法重载的比较

| 名称             | 发生范围       | 方法名   | 参数列表                           | 返回类型                               | 修饰符                             |
| ---------------- | -------------- | -------- | ---------------------------------- | -------------------------------------- | ---------------------------------- |
| 重载（overload） | 本类           | 必须一样 | 类型，个数或者顺序至少有一个不一样 | 无要求                                 | 无要求                             |
| 重写（override） | 父子类（继承） | 必须一样 | 必须一样                           | 返回类型与父类返回类型一致或者是其子类 | 子类方法不能缩小父类方法的访问范围 |



#### 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

##### 多态的体现

1.方法的多态

重载和重写

2.对象的多态

（1）一个对象的编译类型和运行类型可以不一致

（2）编译类型在定义对象时，就确定了，不能改变

（3）运行类型是可以变化的

（4）编译类型看定义时 = 号的左边，运行类型看 = 号的右边



例如：

```java
Animal animal = new Dog dog();
```

编译类型是Animal ，运行类型是Dog

```java
animal = new Cat cat();
```

Animal的运行类型变成了Cat，编译类型仍然是Animal







##### 多态注意事项和细节讨论

1.多态的前提是：两个对象存在继承关系

2.多态的向上转型

1）本质：父类的引用指向了子类对象

2）语法：父类类型   引用名 = new 子类类型（）

3）特点：编译类型看左边，运行类型看右边；

​				可以调用父类中的所有成员（需要遵守访问权限）；

​				不能调用子类中的特有成员；

​				最终运行效果看子类中的具体实现。

3.多态的向下转型

1）语法：子类类型 引用名 = （子类类型）父类引用名

2）只能强转父类的引用，不能强转父类的对象

3）要求父类的引用必须指向的是当前目标类型的对象

4）当向下转型后，可以调用子类类型中所有的成员

4.属性没有重写之说，属性的值看编译类型

InstanceOf比较操作符，**用于判断对象的类型**是否为xx类型或者是否为xx类型的子类型

（关于instanceof可以看知乎R大的文章）





##### JAVA的动态绑定机制

1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定

2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用





##### 多态的应用

1.多态数组

数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

2.多态参数

方法定义的形参类型为父类类型，实参类型允许为子类类型









#### 四种访问控制修饰符

java提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

1.公开级别：用public修饰，对外公开

2.受保护级别：用protected修饰，对子类和用一个包中的类公开

3.默认级别：没有修饰符号，向同一个包的类公开

4.私有级别：用priviate修饰，只有类本身可以访问，不对外公开



使用注意事项

1.修饰符可以用来修饰类中的属性，成员方法以及类

2.只有默认的public才能修饰类！并且遵循上述访问权限的特点

3.

4.成员方法的访问规则和属性完全一样









### Object类

##### 1.==和equals的对比

1）==：既可以判断基本类型，又可以判断引用类型

2）==：如果判断基本类型，判断的是值是否相等

3）==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象

##### equals方法

4）equals：是Object类中的方法，只能判断引用类型

5)默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Interger,String

##### hashcode方法

1.提高具有哈希结构的容器的效率！

2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的

3.两个引用，如果指向的是不同对象，则哈希值是不一样的 

4.哈希值主要根据地址号来的，，不能完全将哈希值等价于地址。

5.A obj1 = new A(); Aobj2 = new A(); Aobj3 = obj1;      

6.后面的集合中国hashcode如果有需要的话，也会重写

##### toString方法

1.基本介绍

默认返回：全类名+@+哈希值的十六进制，查看Object的toString方法，子类往往重写toString方法，用于返回对象的属性信息

2.重写toString方法，打印对象或拼接对象时，都会自动调整用该对象的toString形式。

3.当直接输出一个对象时，toString方法会被默认的调用

##### finalize方法

1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些** **的操作

2.什么时候被回收：当某个对象没用任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。

3.垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制





## java高级特性

### 类变量和类方法 （静态）

##### 什么是类变量：

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

##### 如何定义类变量

定义语法：

访问修饰符 static 数据类型 变量名；//推荐

static 访问修饰符 数据类型 变量名；

##### 如何访问类变量

类名.类变量名（类变量是随类的加载而创建，所以即使没有创建对象实例也可以访问）

或者 对象名.类变量名（静态变量的访问修饰符的访问权限和范围 和普通属性是一样的）





##### static变量是对象共享，不管static变量在哪里，共识

1）static变量是同一个类所有对象共享的

2）static类变量，在类加载的时候生成了



##### 类变量使用注意事项和细节讨论

1.什么时候需要用类变量

当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（将要变量）：比如定义学生类，统计所有学生共交多少钱。Student（name，fee）

2.类变量与实例变量（普通属性）区别

类变量是该类的所有对象共享的，而实例变量是对每个对象独享的。

3.加上static成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4.类变量可以通过 类名  类变量名  或者  对象名 类变量名 来访问。但是java设计者推荐我们使用类名.类变量名方式访问。（前提是满足访问修饰符的访问权限和范围）

5.实例变量不能通过  类名.类变量名  方式访问

6.类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了

7.类变量的生命周期是随类的加载开始，随类的消亡而消亡。



类方法使用注意事项和细节讨论

1.类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数

普通的方法中隐含着this的参数

2.类方法可以通过调用类名用，也可以通过对象名调用。

3.普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用。

4.类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以。

5.类方法（静态方法）中 只能访问 静态变量 或静态方法。

6.普通成员方法，既可以访问 普通变量（方法），也可以访问静态变量（方法）。

小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）



### main方法

深入理解main方法

解释main方法的形式：public static void main(String[] args)

1.main方法时虚拟机调用

2.java虚拟机需要调用类的main（）方法时，所以该方法的访问权限必须是public-----虚拟机与main方法不在一个类

3.java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static

4.该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数

5.java执行的程序 参数1 参数2 参数3



特别提示：

1.在main（）方法中，我们可以直接调用main方法所在类的静态方法或静态属性

2.但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员

在idea下传递参数

![](/Users/wubianhu/Library/Application Support/typora-user-images/image-20211019165731819.png)

![image-20211019165813071](/Users/wubianhu/Library/Application Support/typora-user-images/image-20211019165813071.png)





### 代码块

#### 基本介绍

代码化块又称为**初始化块**，属于类中的成员（即 是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或者创建对象时隐时调用。

#### 基本语法

[修饰符]{

code

};

说明注意：

1.修饰符  可选，要写的化，也只能写static

2.代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块。

3.逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）

4.；号可以写上，也可以省略。





##### 代码块的好处

1.相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化操作

2.场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性





##### 代码块使用注意事项和细节讨论

1.static代码块也叫静态代码块，作用就是对类进行初始化，而且随着**类的加载**而执行，并且只会**执行一次**。如果是普通代码块，每创建一个对象，就执行。

2.类什么时候被加载

- 创建对象实例时（new）
- 创建子类对象实例时，父类也会被加载，先加载父类再加载子类。
- 使用类的静态成员时（静态属性，静态方法），先加载静态代码块，再加载静态属性
- 普通代码块，在创建对象实例时，会被隐时的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。

小结：

1.static代码块是类加载时执行，只会执行一次

2.普通代码块是在创建对象时被调用的，创建一次，调用一次

- 创建一个对象时，在一个类调用顺序是：

  1.调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）

  2.调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）	

  3.调用构造方法。

  4.代码块的调用优先于构造器

  5.构造器的最前面其实隐含了super（）和调用普通代码块，

- 创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：

  1. 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
  2. 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
  3. 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
  4. 父类的构造方法
  5. 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
  6. 子类的构造方法

- 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员

### 关键字

#### final：

final可以修饰类、属性、方法和局部变量。

在某些情况下，程序员可能有以下需求，就会使用到final：

1.当不希望类被继承时，可以私用final修饰

2.当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰。

3.当不希望类的某个属性的值被修改，可以用final修饰

4.当不希望某个局部变量被修改，可以使用final修饰



final使用注意事项和细节讨论

1.final修饰的属性又叫常量，一般用xx_xx_xx来命名

2.final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：

- 在定义时：如public final double TAX_RATE=0.08;
- 在构造器中
- 在代码块中

3.如果final修饰的属性是静态的，则初始化的位置只能是1⃣️定义时2⃣️在静态代码块。不能在构造器中赋值

4.final类不能被继承，但是可以实例化对象

5.如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。

6.一般来说，如果一个类已经是final类类，就没必要再将方法修饰成final方法。

7.final不能修饰构造方法（即构造器）

8.final和static往往搭配使用，效率更高，**不会导致类加载，**底层编译器做了优化处理。

9.包装类（Integer，Double,Float,Boolen等都是final），String也是final类



### 抽象类

1.用abstract关键字来修饰一个类时，这个类就叫抽象类

**访问修饰符 abstract 类名{**

**}**

2.用abstract关键字来修饰一个方法时，这个方法就是抽象方法

**访问修饰符 abstract 返回类型 方法名（参数列表）**;//没有方法体

3.抽象类的价值多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类（）



抽象类使用的注意事项和细节讨论

1.抽象类不能被实例化

2.抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法

3.一旦类包含了abstract方法，则这个类必须声明为abstract

4.abstract只能修饰类和方法，不能修饰属性和其他的。 

5.抽象类可以有任意成员（因为抽象类本质还是类）比如：非静态方法、构造器、静态属性等等

6.抽象方法不能有主体

7.如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己声明为abstract类。

8.抽象方法不能使用priviate、final和static来修饰，因为这些关键字都是和重写相违背的。

### 接口

接口就是给出一些没有实现的方法，封装在一起，在某个类要使用的时候，再根据具体情况把这些方法写出来

注意事项：

在jdk1.7之前。接口的所有方法都没有方法体

在jdk1.8之后，接口类可以有静态方法，默认方法（关键字default，static修饰），也就是说接口中可以有方法的具体实现。

```java
interface 接口名{
  //属性
  //方法（1.抽象方法 2.默认方法 3.静态方法）  
}
```

注意事项和相关细节：

1.接口不能实例化

2.接口中的所有方法是public，接口中的抽象方法，可以不用abstract修饰

3.一个普通类实现接口，就必须把这个接口的所有方法都实现

4.抽象类实现接口，可以不用实现接口的 方法

5.一个类可以实现多个接口

6.接口的属性只能是final的，而且是public static final修饰符。比如

```
int i = 1;
//实际上是
public static final i= 1;(必须初始化)
```

7.接口中属性的访问形式：接口名.属性名

8.一个接口不能继承其他的类，但是可以继承多个其他的接口

9.接口的修饰符，只能是public和默认，这点和类的修饰符是一样的 

#### 接口的多态特性

1.多态参数

2.多态数组

3.接口存在多态传递现象

### 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员，内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

```
class Outer{//外部类
	class Inner{//内部类
	
	}  
}
class OtherClass{
//外部其他类
}
```

内部类的分类

定义在外部类局部位置上（比如方法内）：

1）局部内部类（有类名）

2）匿名内部类（没有类名，重点）

定义在外部类的成员位置上：

1）成员内部类（没用static修饰）

2）静态内部类（使用static修饰）

局部内部类的使用

说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。

1.可以直接访问外部类的所有成员，包括私有的

2.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final

3.作用域：仅仅在定义它的方法或代码块中。

4.局部内部类---访问---->外部类的成员【直接访问】

5.外部类---访问---->访问内部类的成员

访问方式：创建对象，再访问（注意：必须在作用域内）

6.外部内部类---不能访问----->局部内部类（因为 局部内部类地位是一个局部变量）

7.如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问

记住：1.局部内部类定义在方法中/代码块中

2.作用域在方法体或者代码块中

3.本质仍是一个类

### 集合

### 泛型

### 流

### 反射

如何根据类名来获取类的完整信息，分为2步：

1.根据类名来获取类的Class对象

2.通过Class对象的函数接口，来读取“类的构造函数，成员变量“等信息

#### 获取Class对象的方法

##### 1.Class.forName("类名字符串") （注意：类名字符串必须是全称，包名+类名)

##### 2.类名.class

##### 3.实例对象.getClass()

##### 4.”类名字符串“.getClass()



#### 获取构造函数

1.getConstructor()只能获取public权限的构造器

2.getDeclaredConstructor()可以获取类中任意的构造函数，包括public，priviate，protected方法

3.getEnclosingConstructor()，官方说法是“如果该 Class 对象表示构造方法中的一个本地或匿名类，则返回 Constructor 对象，它表示底层类的立即封闭构造方法。否则返回 null。” 通俗点来说，就是“如果一个类A的构造函数中定义了一个内部类InnerA，则通过InnerA的Class对象调用getEnclosingConstructor()方法，可以获取类A的这个构造函数”。

#### 获取成员方法

#### 获取成员变量



### 注解（Annotation)

#### 内置的注解（7个，4个元注解+3个lang注解）

##### 元注解(作用在其他注解的注解）：

@Retention:标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。

@Documented:标记这些注解是否包含在用户文档中。

@Target: 标记这个注解应该是哪种 Java 成员。

@Inherited:标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

##### 作用在代码中的注解：

@Override:检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。

@Deprecated:标记过时方法。如果使用该方法，会报编译警告。

@SuppressWarnings:指示编译器去忽略注解中声明的警告。



##### Annotation组成部分：

有三个重要的组成类：

Annotation.java：这是一个接口，可以通俗理解为每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。

ElementType.java：指定这个注解的使用用途

RetentionPolicy.java：它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。



##### Annotation通用定义

```java
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation1 {
  //使用@interface自定义注解时，自动继承了java.lang.annotation.Annotataion接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。
}
```

##### 对于String[] value()default{};的理解

当注解中使用的属性名为value时，对其赋值时可以不指定属性的名称而直接写上属性值接口；除了value以外的变量名都需要使用name=value的方式赋值





##### Annotation的作用

###### 1.编译检查

例如@Override,在父类中没有同名方法，但是却@用Override标注会报错误

###### 2.在反射中使用Annotation

###### 3.根据Annotation生成帮助文档

通过给Annotation注解加上@Documented标签，能使该Annotation标签出现在javadoc中

###### 4.能够帮忙查看代码





### 线程调度

### 网络编程

### xml

### idea快捷键（windows）

ctrl + h 查看类的继承情况







typora的一些mac快捷键

option+command+c : 插入代码

command+12345 : 标题字号大小

